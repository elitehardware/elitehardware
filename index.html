<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Live Geopolitical Risk Monitor â€” RSS (No API)</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
  :root{--bg:#0f1724;--card:#0b1220;--muted:#94a3b8;--accent:#ffb020;--good:#16a34a;--bad:#ef4444}
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;margin:0;background:linear-gradient(180deg,#071027 0%, #071327 100%);color:#e6eef7}
  .wrap{max-width:1100px;margin:20px auto;padding:18px}
  header{display:flex;align-items:center;gap:12px}
  h1{margin:0;font-size:20px}
  .grid{display:grid;grid-template-columns:1fr 420px;gap:14px;margin-top:14px}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03);padding:12px;border-radius:10px;box-shadow:0 6px 30px rgba(2,6,23,0.6)}
  label{display:block;font-size:13px;color:var(--muted);margin-top:8px}
  .controls{display:flex;gap:8px;align-items:center}
  button{background:var(--accent);border:none;color:#071327;padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .muted{color:var(--muted);font-size:13px}
  .small{font-size:13px}
  .headline{padding:8px;border-radius:8px;margin-bottom:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
  .kw{font-weight:700;color:var(--accent)}
  .score-circle{width:140px;height:140px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:26px;margin:12px auto;background:linear-gradient(135deg, rgba(255,176,32,0.08), rgba(255,176,32,0.04));border:1px solid rgba(255,176,32,0.08)}
  .source-toggle{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
  .chip{padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);cursor:pointer}
  .chip.on{background:linear-gradient(90deg, rgba(16,185,129,0.12), rgba(59,130,246,0.06));border-color:rgba(59,130,246,0.14)}
  footer{margin-top:12px;color:var(--muted);font-size:13px}
  .topline{display:flex;justify-content:space-between;align-items:center;gap:20px}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>ðŸ›° Live Geopolitical Risk Monitor (RSS â€” No API)</h1>
      <div class="muted small">Aggregates public RSS feeds, computes a transparency-first risk score. Use as demo/awareness only.</div>
    </div>
  </header>

  <div class="grid">
    <!-- left: controls & feed -->
    <div>
      <div class="card">
        <div class="topline">
          <div>
            <label class="small">Sensitivity</label>
            <input id="sensitivity" type="range" min="0.4" max="2.0" step="0.1" value="1.0" />
          </div>
          <div style="text-align:right">
            <div class="muted small">Status: <span id="status">idle</span></div>
            <div style="margin-top:6px" class="controls">
              <button id="start">Start</button>
              <button id="stop" class="ghost" disabled>Stop</button>
              <button id="refresh" class="ghost">Refresh</button>
            </div>
          </div>
        </div>

        <label class="small">Feeds (toggle to include/exclude)</label>
        <div id="feedToggles" class="source-toggle"></div>

        <label class="small">Proxies (fallback order â€” used automatically)</label>
        <div class="muted small">
          <div>Using public proxy chain to overcome browser CORS. These are for demos only.</div>
          <ul class="muted small">
            <li>https://api.allorigins.win/raw?url=</li>
            <li>https://thingproxy.freeboard.io/fetch/</li>
            <li>https://api.allorigins.win/get?url= (fallback)</li>
          </ul>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <h3 style="margin:0">Recent matched headlines</h3>
        <div id="headlines" style="max-height:520px;overflow:auto;margin-top:8px"></div>
      </div>
    </div>

    <!-- right: viz -->
    <div>
      <div class="card">
        <h3 style="margin:0">Live risk</h3>
        <div id="scoreWrap">
          <div id="scoreCircle" class="score-circle">â€”</div>
          <div class="muted small" style="text-align:center">0 = low / 100 = high (heuristic)</div>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <h3 style="margin:0">Timeline</h3>
        <canvas id="chart" width="400" height="200" style="margin-top:8px"></canvas>
      </div>

      <div class="card" style="margin-top:12px">
        <h3 style="margin:0">Signals & top sources</h3>
        <div id="signals" style="margin-top:8px"></div>
      </div>
    </div>
  </div>

  <footer>
    <div class="muted small">Note: This is a heuristic tool for experimentation. It is not an authoritative or predictive intelligence product.</div>
  </footer>
</div>

<script>
/* =========================
   Configuration & feeds
   ========================= */
const FEEDS = {
  "BBC": "https://feeds.bbci.co.uk/news/world/rss.xml",
  "Reuters": "https://feeds.reuters.com/reuters/worldNews",
  "Al Jazeera": "https://www.aljazeera.com/xml/rss/all.xml",
  "UN": "https://www.un.org/press/en/rss.xml",
  "NATO": "https://www.nato.int/cps/en/natohq/news_rss.htm"
};

// proxy chain (try in order)
const PROXIES = [
  "https://api.allorigins.win/raw?url=",
  "https://thingproxy.freeboard.io/fetch/",
  "https://api.allorigins.win/get?url=" // some proxies return wrapped JSON â€” parser handles both
];

// Source reliability multipliers
const SOURCE_RELIABILITY = {
  "NATO": 1.7,
  "UN": 1.6,
  "Reuters": 1.35,
  "BBC": 1.25,
  "Al Jazeera": 1.15,
  "Unknown": 0.8
};

// Major countries to boost severity
const MAJOR_COUNTRIES = ["usa","united states","china","russia","iran","north korea","ukraine","nato","israel"];

// Risk factor categories and weights
const RISK_FACTORS = {
  military: {keywords: ["missile","troop","invasion","military","airstrike","shelling","drill","mobiliz"], weight: 4},
  diplomacy: {keywords: ["talks","negotiation","sanction","agreement","ceasefire","diplomat","negotiat"], weight: 2},
  economic: {keywords: ["oil prices","trade war","sanction","market","inflation"], weight: 2.5},
  nuclear: {keywords: ["nuclear","uranium","warhead","detonat","atomic"], weight: 8}
};

// small sentiment lexicon (in-browser; not ML)
const POS_WORDS = ["peace","agreement","ceasefire","truce","accord","negotiation","deal"];
const NEG_WORDS = ["attack","invasion","bomb","killed","dead","escalat","strike","retaliat","shelling","casualties"];

/* =========================
   UI references
   ========================= */
const statusEl = document.getElementById('status');
const startBtn = document.getElementById('start');
const stopBtn = document.getElementById('stop');
const refreshBtn = document.getElementById('refresh');
const feedToggles = document.getElementById('feedToggles');
const headlinesEl = document.getElementById('headlines');
const scoreCircle = document.getElementById('scoreCircle');
const sensitivityInput = document.getElementById('sensitivity');
const signalsEl = document.getElementById('signals');

let enabledFeeds = Object.keys(FEEDS);
let pollTimer = null;
let timeline = JSON.parse(localStorage.getItem('risk_timeline') || '[]'); // array of {t, v}
const MAX_HISTORY = 120;

/* =========================
   Helpers: fetch with proxy fallbacks
   ========================= */
async function fetchWithProxies(url){
  for(const p of PROXIES){
    try{
      const full = p + encodeURIComponent(url);
      const resp = await fetch(full, {cache: "no-store"});
      if(!resp.ok) throw new Error(resp.status + ' ' + resp.statusText);
      // some proxies return raw XML; some (allorigins get) returns JSON {contents: "..."}
      const txt = await resp.text();
      // try to extract XML if wrapped:
      if(txt.trim().startsWith('{')){
        try{
          const j = JSON.parse(txt);
          if(j.contents) return j.contents;
        }catch(e){}
      }
      return txt;
    }catch(e){
      // try next proxy silently
      console.warn('proxy failed', p, e);
    }
  }
  throw new Error('All proxies failed');
}

/* =========================
   Parse RSS XML -> articles
   ========================= */
function parseRSS(xmlText, sourceName){
  try{
    const doc = new DOMParser().parseFromString(xmlText, "application/xml");
    // common item selectors: item (RSS) or entry (Atom)
    const items = Array.from(doc.querySelectorAll('item, entry')).slice(0,4);
    return items.map(it => {
      const title = (it.querySelector('title')?.textContent || '').trim();
      const desc = (it.querySelector('description')?.textContent || it.querySelector('summary')?.textContent || '').trim();
      const link = (it.querySelector('link')?.textContent || it.querySelector('link')?.getAttribute('href') || '') || '';
      const pubDate = (it.querySelector('pubDate')?.textContent || it.querySelector('published')?.textContent || '') || '';
      return {source: sourceName, title, desc, link, pubDate, text: (title + ' ' + desc).trim()};
    });
  }catch(e){
    console.warn('parse error for', sourceName, e);
    return [];
  }
}

/* =========================
   Scoring logic
   ========================= */
function sentimentScore(text){
  const t = text.toLowerCase();
  let s = 0;
  for(const w of POS_WORDS) if(t.includes(w)) s -= 1;
  for(const w of NEG_WORDS) if(t.includes(w)) s += 1;
  return Math.max(-5, Math.min(5, s)); // clamp
}

function analyzeArticle(article, sensitivity=1.0){
  const t = article.text.toLowerCase();
  let severity = 0;
  const signals = [];

  // category keywords
  for(const [cat, data] of Object.entries(RISK_FACTORS)){
    for(const kw of data.keywords){
      if(t.includes(kw)){
        severity += data.weight * sensitivity;
        signals.push({type:cat, kw, weight: data.weight});
      }
    }
  }

  // major country boost
  for(const c of MAJOR_COUNTRIES){
    if(t.includes(c)){
      severity += 5 * sensitivity;
      signals.push({type:'major_country', kw:c, weight:5});
    }
  }

  // sentiment
  const sent = sentimentScore(t);
  if(sent > 0) severity -= Math.abs(sent) * 0.8; // positive reduces
  if(sent < 0) severity += Math.abs(sent) * 1.2; // negative increases
  // source reliability multiplier applied later at overall aggregation

  return {severity, signals, sentiment: sent};
}

/* combine article scores into a global score */
function aggregateScores(articles, sensitivity=1.0){
  // per-source weighted sum
  let raw = 0;
  const perSource = {};
  const keywordSources = {}; // for narrative alignment
  const details = [];

  for(const a of articles){
    const s = analyzeArticle(a, sensitivity);
    const srcKey = a.source || 'Unknown';
    const reliability = SOURCE_RELIABILITY[srcKey] || SOURCE_RELIABILITY[Object.keys(SOURCE_RELIABILITY).find(k=>srcKey.includes(k))] || (SOURCE_RELIABILITY['Unknown'] || 1);
    const weighted = s.severity * reliability;

    raw += weighted;
    perSource[srcKey] = (perSource[srcKey] || 0) + weighted;

    for(const sig of s.signals){
      const k = sig.kw;
      keywordSources[k] = keywordSources[k] || new Set();
      keywordSources[k].add(srcKey);
    }

    details.push({article:a, severity:s.severity, weighted, signals:s.signals, sent:s.sentiment});
  }

  // narrative alignment: count keywords seen in multiple sources
  let narrativeBoost = 0;
  const aligned = {};
  for(const [kw, setSrc] of Object.entries(keywordSources)){
    if(setSrc.size >= 2){
      aligned[kw] = Array.from(setSrc);
      narrativeBoost += 3 * setSrc.size; // increases with number of sources
    }
  }

  // normalize raw to 0..100 heuristic
  // heuristic normalization parameters (tunable)
  const base = raw + narrativeBoost;
  // apply diminishing returns scaling
  const scaled = 100 * (1 - Math.exp(-base / 25));
  const finalScore = Math.max(0, Math.min(100, Math.round(scaled)));

  return {finalScore, raw, scaled, perSource, aligned, details};
}

/* =========================
   UI rendering & loop
   ========================= */
const ctx = document.getElementById('chart').getContext('2d');
const chart = new Chart(ctx, {
  type:'line',
  data:{labels: timeline.map(x=>x.t), datasets:[{label:'Risk', data: timeline.map(x=>x.v), fill:true, tension:0.3}]},
  options:{responsive:true, scales:{y:{min:0,max:100}}}
});

function updateChart(value){
  const t = new Date().toLocaleTimeString();
  timeline.push({t, v: value});
  if(timeline.length > MAX_HISTORY) timeline.shift();
  localStorage.setItem('risk_timeline', JSON.stringify(timeline));
  chart.data.labels = timeline.map(x=>x.t);
  chart.data.datasets[0].data = timeline.map(x=>x.v);
  chart.update();
}

/* render feed toggles */
function makeFeedToggles(){
  feedToggles.innerHTML = '';
  Object.keys(FEEDS).forEach(name=>{
    const chip = document.createElement('div');
    chip.className = 'chip on';
    chip.textContent = name;
    chip.onclick = () => {
      chip.classList.toggle('on');
      enabledFeeds = Array.from(feedToggles.querySelectorAll('.chip.on')).map(c=>c.textContent);
    };
    feedToggles.appendChild(chip);
  });
  // initial enabled list set
  enabledFeeds = Object.keys(FEEDS);
}
makeFeedToggles();

/* render headlines */
function renderHeadlines(articles, keywords){
  headlinesEl.innerHTML = '';
  for(const a of articles){
    const el = document.createElement('div');
    el.className = 'headline';
    // highlight keywords
    let title = a.title;
    for(const kw of keywords){
      const re = new RegExp(kw.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'), 'ig');
      title = title.replace(re, m => `<span class="kw">${m}</span>`);
    }
    el.innerHTML = `<div style="font-weight:700">${title}</div>
                    <div class="muted small">${a.source} â€¢ ${a.pubDate || ''}</div>
                    <div class="muted small" style="margin-top:6px">${a.desc ? a.desc.substring(0,220) : ''}</div>
                    <div style="margin-top:6px"><a href="${a.link}" target="_blank" rel="noopener" class="muted small">read</a></div>`;
    headlinesEl.appendChild(el);
  }
}

/* fetch all enabled feeds */
async function fetchAllFeeds(){
  statusEl.textContent = 'fetching...';
  const articles = [];
  const feedNames = enabledFeeds.length ? enabledFeeds : Object.keys(FEEDS);
  for(const name of feedNames){
    const url = FEEDS[name];
    try{
      const xml = await fetchWithProxies(url);
      const parsed = parseRSS(xml, name);
      articles.push(...parsed);
    }catch(e){
      console.warn('feed failed', name, e);
      // skip silently
    }
  }
  statusEl.textContent = 'done';
  return articles;
}

/* one polling pass */
async function pollOnce(){
  try{
    const sensitivity = parseFloat(sensitivityInput.value || 1.0);
    const articles = await fetchAllFeeds();
    if(!articles.length){
      statusEl.textContent = 'no articles';
      return;
    }

    // analyze
    const agg = aggregateScores(articles, sensitivity);

    // render headlines (use top matched keywords as highlight)
    const topKeywords = Object.keys(agg.aligned).length ? Object.keys(agg.aligned) : Object.values(agg.details).flatMap(d=>d.signals.map(s=>s.kw)).slice(0,12);
    renderHeadlines(articles.slice(0,40), Array.from(new Set(topKeywords)));

    // display score
    scoreCircle.textContent = agg.finalScore + '/100';
    updateChart(agg.finalScore);

    // signals panel
    signalsEl.innerHTML = '';
    const s1 = document.createElement('div');
    s1.innerHTML = `<div class="muted small">Raw: ${Math.round(agg.raw)} â€¢ Scaled: ${Math.round(agg.scaled)}</div>`;
    signalsEl.appendChild(s1);

    const srcList = document.createElement('div');
    srcList.className = 'muted small';
    srcList.innerHTML = '<strong>Top sources (impact)</strong><br/>';
    Object.entries(agg.perSource).sort((a,b)=>b[1]-a[1]).slice(0,6).forEach(([src,val])=>{
      const el = document.createElement('div');
      el.textContent = `${src}: ${Math.round(val)}`;
      srcList.appendChild(el);
    });
    signalsEl.appendChild(srcList);

    if(Object.keys(agg.aligned).length){
      const alignEl = document.createElement('div');
      alignEl.style.marginTop = '8px';
      alignEl.innerHTML = `<strong>Aligned narratives</strong><div class="muted small">${Object.entries(agg.aligned).map(([k,arr])=>`${k}: ${arr.join(', ')}`).join(' â€¢ ')}</div>`;
      signalsEl.appendChild(alignEl);
    }

    statusEl.textContent = `last: ${new Date().toLocaleTimeString()} (articles: ${articles.length})`;
  }catch(e){
    console.error(e);
    statusEl.textContent = 'error';
  }
}

/* start/stop controls */
startBtn.addEventListener('click', ()=>{
  if(pollTimer) clearInterval(pollTimer);
  pollOnce(); // immediate
  pollTimer = setInterval(pollOnce, 30_000); // every 30s
  startBtn.disabled = true;
  stopBtn.disabled = false;
  statusEl.textContent = 'running';
});
stopBtn.addEventListener('click', ()=>{
  if(pollTimer) clearInterval(pollTimer);
  pollTimer = null;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  statusEl.textContent = 'stopped';
});
refreshBtn.addEventListener('click', ()=> pollOnce());

/* initial chart render if history exists */
if(timeline.length) chart.update();

/* quick first fetch */
(async ()=> {
  // small warmup: attempt a quick fetch to detect CORS/proxy viability
  try{ await fetchAllFeeds(); }catch(e){ console.warn('warmup fetch failed', e) }
})();

</script>
</body>
</html>
